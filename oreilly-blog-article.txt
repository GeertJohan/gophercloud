Introducing Gophercloud
A new SDK for Go with big aspirations

Samuel A. Falvo II, @samuelafalvoii, +Samuel Falvo II

If you work extensively with Go and with cloud services, you might take an interest in a new package called Gophercloud.  Gophercloud aims to fill the multi-cloud API niche for Go, just as fog, libcloud, and jclouds do for Ruby, Python, and Java.  We feel that cloud applications should not tether themselves to a single vendor's API unnecessarily, making redundancy through isolated providers a more attainable goal, and helping to level the playing field by avoiding vendor lock-in.

Presently, Gophercloud works with OpenStack's compute API.  However, with time and some elbow grease, we will add APIs for other services to its portfolio.  Through internal development here at Rackspace and through external contributions from users of other providers, we hope Gophercloud will evolve to meet the needs of dev-ops engineers working in Go everywhere.

Code Example

Suppose you are in charge of maintaining your company's web servers.  Recently, your hypothetical boss tasks you with writing software that monitors how many web servers remain in service.  To make this even more contrived, let's say there's some perfectly valid reason you cannot use your provider's load-balancing or autoscale features.  Your hypothetical boss clarifies, loudly, "We need at least 10 web server instances at any given time!  Make it happen!"  You'd probably end up with a program not too different from listing 1.

You start by writing a main function that parses the command-line arguments and performs a basic sanity check on the supplied username and password.  Next, you attempt to authenticate with the provider using the supplied username and password.  You enable automatic reauthentication, so that you don't have to worry about doing this yourself as the program runs.  After all, you expect this program to serve for at least a year or two.  Once authenticated, you need to get a reference to the cloud servers API.  You do this by searching the service catalog returned by the authentication step earlier.  Finally, you enter an endless loop that attempts to re-fortify the web servers every five minutes or so.

Looking at the fortifyWebServers() function, you start by logging when you enter and leave the function.  Next, you get a list of servers already in the account.  You tally how many production servers exist based on the company's naming convention.  By the way, if your organization uses custom metadata for this, you could inspect the servers.Metadata map for this information as well.  Finally, you instantiate a new server as long as you have fewer than the alloted minimum amount.  The image on each new server will cause it to seek its appropriate configuration from a well-known configuration master.

And hey presto! You've created servers using a multi-cloud Go API!

Where We're Going Tomorrow

Earlier, I said that Gophercloud intends to provide a multi-cloud API for writing cloud services.  As of this writing, if you look at Gophercloud's GitHub repository, though, you'll find a lot of functionality missing.  In fact, Gophercloud's API only offers support for OpenStack's Cloud Server API.  However, we're working to improve the depth and breadth of the API not only within the realm of OpenStack itself, but also across different cloud providers as well.  For instance, a design document concerning support for cloud files now exists; since its publication, contributors responded with valuable feedback which will help shape the future of the API.

We have deliberately chosen to take incremental steps when building Gophercloud.  Incremental development trumps a conceptually cleaner, but more encompassing, design which has no backing code to demonstrate its viability.  It allows us to learn what works and what doesn't early in its development history.  As more contributors lend their expertise and we gain more experience with other providers, I'm confident that Gophercloud will gain the ability to work with other providers as easily as it would with OpenStack.  Our resources are limited, however, which is why we are especially grateful for external contributions for different APIs.

Gophercloud currently has a semantic version of 0.0, implying its interface remains fluid as we try to increase our understanding of how the API should work.  However, where possible, we design for upward-compatibility.  Once we reach version 1.0, everything adheres to the Go community standard of never breaking backward compatibility.  Should any breaking change need to happen, a new repository will be created for that purpose.  

Conclusion

I hope this post illustrates what you can do with Gophercloud, and gives a forward-looking view of where the project is headed.  We hope to attract sufficient interest from the community to help us realize our goals for Gophercloud sooner rather than later.  Visit us at http://gophercloud.io, and join our developers mailing list.  We'd love to see you!


Listing 1.


package main

import (
	"crypto/rand"
	"flag"
	"fmt"
	"github.com/rackspace/gophercloud"
	"log"
	"strings"
	"time"
)

var provider = flag.String("provider", "rackspace-us", "OpenStack provider of choice")
var username = flag.String("username", "", "Cloud account username")
var password = flag.String("password", "", "Cloud account password")
var imageRef = flag.String("imageRef", "c52a0ca6-c1f2-4cd1-b7d6-afbcd1ebda22", "Web server image ID")
var flavorRef = flag.String("flavorRef", "2", "Web server flavor ID")
var minimumServerCount = flag.Int("count", 10, "Minimum number of servers")
var prodPrefix = flag.String("prefix", "ProdWeb-", "Prefix used to identify production servers")

func main() {
	flag.Parse()
	if *username == "" || *password == "" {
		log.Fatal("Either username or password is invalid")
	}

	acc, err := gophercloud.Authenticate(*provider, gophercloud.AuthOptions{
		Username:    *username,
		Password:    *password,
		AllowReauth: true,
	})
	if err != nil {
		log.Fatal(err)
	}

	api, err := gophercloud.ServersApi(acc, gophercloud.ApiCriteria{
		Name:      "cloudServersOpenStack",
		VersionId: "2",
		UrlChoice: gophercloud.PublicURL,
	})
	if err != nil {
		log.Fatal(err)
	}

	for {
		err := fortifyWebServers(api)
		if err != nil {
			log.Print(err)
		}
		time.Sleep(5 * time.Minute)
	}
}

func fortifyWebServers(api gophercloud.CloudServersProvider) error {
	log.Print("Fortification check starting.")
	defer log.Print("Fortification check complete.")

	servers, err := api.ListServers()
	if err != nil {
		return err
	}

	productionServers := 0
	for _, s := range servers {
		if strings.HasPrefix(s.Name, *prodPrefix) {
			productionServers++
		}
	}

	for productionServers < *minimumServerCount {
		err := addOneMoreServer(api)
		if err != nil {
			return err
		}
		productionServers++
	}

	return nil
}

func addOneMoreServer(api gophercloud.CloudServersProvider) error {
	_, err := api.CreateServer(gophercloud.NewServer{
		Name:      fmt.Sprintf("%s%s", *prodPrefix, randomString(16)),
		ImageRef:  *imageRef,
		FlavorRef: *flavorRef,
	})
	return err
}

func randomString(length int) string {
	const alphanum = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	var bytes = make([]byte, length)
	rand.Read(bytes)
	for i, b := range bytes {
		bytes[i] = alphanum[b%byte(len(alphanum))]
	}
	return string(bytes)
}
